# Java0期毕业总结

## 一、JVM

JVM章节主要学习了JVM基础知识，Java字节码技术、JVM类加载器、JVM内存模型、JVM启动参数等内容。其中的重点在于JVM类加载器、JVM内存模型两个部分；类在JVM类加载器中的生命周期包括以下几个阶段：加载、验证、准备、解析、初始化、使用、卸载；JVM内存结构包括老年代、年轻代以及Non-Heap。新生代又包括Eden区和Survivor区，survivor区通常包括两个s0和s1区。Non-Heap包括元数据区等。一般是默认15代没有回收的就会从年轻代进入老年代。

## 二、NIO

主要学习了五种IO模型，阻塞式IO（BIO），等一个处理完，才会处理下一个；非阻塞式IO（NIO），内核立即返回，可以继续做其他调的事情，需要不断的询问内核数据处理好了没有；IO多路复用（IO multiplexing）,在单个线程里面同时监控多个套接字，通过
select 或 poll 轮询所负责的所有socket，当某个 socket 有数据到达了，就通知用户进程；信号驱动 I/O，信号驱动 IO 与 BIO 和 NIO 最大的区别就在于，在 IO 执行的数据准备阶段，不会阻塞用户进程。异步式 IO，异步 IO 真正实现了 IO 全流程的非阻塞；

Netty框架：理解Netty的五个关键概念：Channel-代表一个打开的连接,可执行读取/写入 IO 操作；ChannelFuture-代表一个打开的连接,可执行读取/写入 IO 操作，将回调方法传给 ChannelFuture，在操作完成时自动执行； Event & Handler基于事件驱动，事件和处理器可以关联到入站和出站数据流； Encoder &Decoder-处理网络 IO 时，需要进行序列化和反序列化, 转换 Java 对象与字节流；ChannelPipeline-数据处理管道就是事件处理器链。有顺序、同一 Channel 的出站处理器和入站处理器在同一个列表中；

## 三、并发编程

为什么会有多线程？多 CPU 核心意味着同时操作系统有更多的并行计算资源可以使用；操作系统以线程作为基本的调度单元。

线程安全的的三个特性：原子性、可见性、顺序性；Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项 Happens-Before 规则；线程池-Excutor: 执行者 – 顶层接口，ExcutorService: 接口 API，ThreadFactory: 线程工厂，Excutors: 工具类；用锁的时候要考虑的问题：粒度、性能、重入、公平、自旋锁；

## 四、Spring和ORM等框架

Spring主要分为六大模块：Core：Bean/Context/AOP， Testing：Mock/TestContext， DataAccess: Tx/JDBC/ORM，Spring MVC/WebFlux: web， Integration: remoting/JMS/WS，Languages: Kotlin/Groovy；AOP面向切面编程，加了一个中间层，管理对象生命周期与对象装配；IoC-控制反转，也称为DI（Dependency Injection）依赖注入。对象A里指需要依赖一个接口IB，系统启动和装配阶段，把IB接口的实例对象注入到对象A，这样A就不需要依赖一个IB接口的具体实现，也就是类B。可以运行时替换成注入IB接口另一实现类C的一个对象实例。Spring Bean 生命周期，Bean的加载过程：创建对象、属性赋值、初始化、注销接口注册；SpringBoot的两大核心原理一个是自动化配置，一个是spring-boot-starter。

## 五、MySQL 数据库和 SQL

MySQL是关系型数据库，除了关系型数据库，还有非关系型数据库。数据库三大范式，第一范式，保证每个字段的原子性，字段不可拆分；第二范式，在满足第一范式的基础上，非主键字段依赖主键；第三范式，非主键字段，不互相依赖；MySQL的引擎，主要是两个，一个是MYISAM，不支持事务，支持表锁；一个是InnoDB，支持事务，支持行级锁，支持外键，是MYSQL默认的引擎。InnoDB默认使用B+树作为索引；mysql事务的ACID原则，原子性、一致性、隔离性、持久性；mysql事务的四个级别，读未提交、读已提交、可重复读、可串行化；

## 六、分库分表

MYSQL主从复制的原理核心是，主库写binlog，从库写relay log。主从复制的局限性，延迟问题、应用侧需要配合读写分离框架、不解决高可用问题；读写分离，ShardingSphere-jdbc 的 Master-Slave 功能，可以实现SQL解析和事务管理，自动实现读写分离；解决写完读不一致的问题；主从结构解决了高可用，读扩展，但是单机容量不变，单机写性能无法解决。提升容量-->分库分表，分布式，多个数据库，作为数据分片的集群提供服务，降低单个节点的写压力，提升整个系统的数据容量上限。数据库可以垂直拆分，也可以水平拆分。可以用 以 ShardingSphere- Proxy来实现分库分表；数据迁移可以通过 binlog+ 全量 + 增量的方式来实现；

## 七、RPC 和微服务

RPC是远程过程调用（Remote Procedure Call）的缩写形式。简单来说，就是“像调用本地方法一样调用远程方法”。RPC是基于接口的远程服务调用。基本原理包含以下几个步骤：本地代理存根: Stub、本地序列化反序列化、网络通信、远程序列化反序列化、远程服务存根: Skeleton、调用实际业务服务、原路返回服务结果、返回给本地调用方；Dubbo框架的六大核心能力:面向接口代理的高性能RPC调用，智能容错和负载均衡，服务自动注册和发现，高度可扩展能力，运行期流量调度，可视化的服务治理与运维。

微服务架构经过了一个逐渐的发展过程，从最初的单体架构，到后来的垂直架构，SOA架构，到微服务架构。微服务架构风格，以实现一
组微服务的方式来开发一个独立的应用系统的方法。其中每个小微服务都运行在自己的进程中，一般采用HTTP 资源 API 这样轻量的机制相互通信。微服务的发展历程经历了微服务、服务网格、数据库网络、云原生。微服务适合用在复杂度较高的地方，随着复杂度升高，单体架构的生产力快速下降，而微服务相对平稳。

## 八、分布式缓存

缓存的本质：系统各级处理速度不匹配，导致利用空间换时间。缓存是提升系统性能的一个简单有效的办法。变动频率大、一致性要求高的数据不太适合用缓存。缓存的有效性可以从读写比和命中率两个方面来进行评价。缓存常见问题，缓存穿透、缓存击穿、缓存雪崩。这里主要学习了Redis的主从复制、集群的使用。这一部分需要自己多动手去实践，才会更加有体会。

## 九、分布式消息队列

系统间通信，异步的消息通信、可以简化参与各方的复杂依赖关系、可以在请求量很大的时候，缓冲一下、某些情况下能保障消息的可靠性，甚至顺序。这就是MQ。MQ的四大作用：异步通信、系统解耦、削峰平谷、可靠通信。消息的处理方式主要有两种，一种是点对点，另一种是发布订阅模式。消息处理的保障-至多一次、至少一次、精确一次。然后主要学习了ActiveMQ以及kafka的使用，这一部分也是需要自己动手去实践才可以。